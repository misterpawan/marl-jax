import chex
import jax.numpy as jnp
from rlax import art
from rlax import PopArtState

Array = chex.Array


def popart_simple(num_outputs: int,
                  step_size: float,
                  scale_lb: float,
                  scale_ub: float,
                  axis_name=None):
  """Generates functions giving initial PopArt state and update rule.

  Args:
    num_outputs: The number of outputs generated by the linear we're preserving.
    step_size: The step size for learning the scale & shift parameters.
    scale_lb: Lower bound for the scale.
    scale_ub: Upper bound for the scale.
    axis_name: What axis to aggregate over, if str. If passed an iterable,
      aggregates over multiple axes. Defaults to no aggregation, i.e. None.

  Returns:
    A tuple of:
      initial_state: A function returning the initial Art state.
      art_update: A function updating the Art state
  """

  def initial_state():
    return PopArtState(
        jnp.zeros([num_outputs]), jnp.ones([num_outputs]),
        jnp.ones([num_outputs]))

  def art_update(state: PopArtState, targets: Array,
                 indices: Array) -> tuple[PopArtState]:
    """Computes the PopArt update.

    Args:
      state: The current PopArt state.
      targets: Values whose distribution to learn.
      indices: For each target, which shift and scale element to adjust.

    Returns:
      A tuple of:
        new_state: The new Art state.
    """
    # Disables Popart if step_size is None
    if step_size is None:
      return state

    # Adaptively rescale targets.
    state_new = art(state, targets, indices, step_size, scale_lb, scale_ub,
                    axis_name)
    return state_new

  return initial_state, art_update
